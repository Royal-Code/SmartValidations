using RoyalCode.SmartProblems;
using RoyalCode.SmartProblems.Entities;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics.CodeAnalysis;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;

namespace RoyalCode.SmartValidations;

/// <summary>
/// Struct to apply validation rules and collect the result.
/// </summary>
public readonly ref struct RuleSet
{
    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)]
    private readonly Type? type;
    private readonly Problems? problems;
    private readonly string? propertyPrefix;

    /// <summary>
    /// Implicit conversion from <see cref="RuleSet"/> to <see cref="Problems"/>.
    /// </summary>
    /// <param name="set"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Problems?(RuleSet set) => set.problems;

    /// <summary>
    /// Create a new rule set for a model to apply validation rules.
    /// </summary>
    /// <typeparam name="T">The model type to validate.</typeparam>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public static RuleSet For<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)]T>() => new(typeof(T));

    /// <summary>
    /// Initialize a <see cref="RuleSet"/>.
    /// </summary>
    /// <param name="type">The type being validated.</param>
    /// <param name="problems">The problems found, if any.</param>
    /// <param name="propertyPrefix">Optional, a prefix of the property name to be removed.</param>
    private RuleSet(
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] Type? type = null,
        Problems? problems = null,
        string? propertyPrefix = null)
    {
        this.type = type;
        this.problems = problems;
        this.propertyPrefix = propertyPrefix;
    }

    /// <summary>
    /// Add a problem to the rule set.
    /// </summary>
    /// <param name="problem">The problem to add.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet WithProblem(Problem problem)
    {
        Problems resultProblems = problems ?? [];
        resultProblems.Add(problem);
        return new RuleSet(type, resultProblems, propertyPrefix);
    }

    /// <summary>
    /// Creates a new <see cref="RuleSet"/> with the specified property prefix appended to the current prefix.
    /// </summary>
    /// <param name="propertyPrefix">The property prefix to append. Cannot be <see langword="null"/>.</param>
    /// <returns>A new <see cref="RuleSet"/> with the updated property prefix.</returns>
    public RuleSet WithPropertyPrefix(string propertyPrefix)
    {
        ArgumentNullException.ThrowIfNull(propertyPrefix);

        var propPrefix = this.propertyPrefix is null
            ? propertyPrefix
            : $"{this.propertyPrefix}.{propertyPrefix}";

        return new RuleSet(type, problems, propPrefix);
    }

    /// <summary>
    /// Get the property name and display name for a given property.
    /// </summary>
    /// <param name="property">The property name that are being validated.</param>
    /// <param name="propertyName">The property name without prefix.</param>
    /// <param name="displayName">The display name of the property.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void GetPropertyNameAndDisplayName(string? property, out string? propertyName, out string displayName)
    {
        propertyName = RemovePrefix(property);
        displayName = GetDisplayName(propertyName);
    }

    /// <summary>
    /// Check if the rule set has any problems.
    /// </summary>
    /// <param name="problems">The problems generated by the rules.</param>
    /// <returns>True if the rule set has problems, false otherwise.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool HasProblems([NotNullWhen(true)] out Problems? problems)
    {
        problems = this.problems;
        return problems is not null;
    }

    #region Not Null

    /// <summary>
    /// Validates a value to ensure that the value is not null.
    /// </summary>
    /// <typeparam name="TValue">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNull<TValue>(
        [NotNullWhen(true)] TValue value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return value is not null 
            ? this 
            : WithNullOrEmptyProblem(property);
    }

    #endregion

    #region Not Empty

    /// <summary>
    /// Validates a string to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        [NotNullWhen(true)] string? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value) 
            ? this 
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a number to ensure that the value is not null or empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty<T>(
        [NotNullWhen(true)] T value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T: INumber<T>
    {
        return BuildInPredicates.NotEmpty(value)
            ? this 
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a number to ensure that the value is not null or empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty<T>(
        [NotNullWhen(true)] T? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, INumber<T>
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a collection to ensure that the value is not null or empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The collection to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty<T>(
        [NotNullWhen(true)] T[]? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a collection to ensure that the value is not null or empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The collection to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty<T>(
        [NotNullWhen(true)] ICollection<T>? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a readonly collection to ensure that the value is not null or empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The readonly collection to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty<T>(
        [NotNullWhen(true)] IReadOnlyCollection<T>? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a collection to ensure that the value is not null or empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The collection to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty<T>(
        [NotNullWhen(true)] IEnumerable<T>? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="DateTime"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="DateTime"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        DateTime value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this 
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="DateTime"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="DateTime"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        [NotNullWhen(true)] DateTime? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="DateTimeOffset"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="DateTimeOffset"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        DateTimeOffset value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="DateTimeOffset"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="DateTimeOffset"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        [NotNullWhen(true)] DateTimeOffset? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="DateOnly"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="DateOnly"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        DateOnly value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="DateOnly"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="DateOnly"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        [NotNullWhen(true)] DateOnly? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="Guid"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="Guid"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        Guid value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="Guid"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="Guid"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        [NotNullWhen(true)] Guid? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : WithNullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates if both values are null or, when one is filled, if both are not empty.
    /// </summary>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothNullOrNotEmpty(
        [NotNullWhen(true)] string? value1,
        [NotNullWhen(true)] string? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
    {
        return BuildInPredicates.BothNullOrNotEmpty(value1, value2)
            ? this
            : WithProblem(Rules.BothNullOrNot, value1, value2, R.BothNullOrNotMessageTemplate, property1, property2);
    }

    #endregion

    #region Null Or Not Empty

    /// <summary>
    /// Validates a value to ensure that the value is null or not empty.
    /// </summary>
    /// <param name="value">The value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrNotEmpty(
        string? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NullOrNotEmpty(value)
            ? this
            : WithProblem(Rules.NullOrNotEmpty, R.NullOrNotMessageTemplate, property);
    }

    /// <summary>
    /// Validates a number to ensure that the value is null or not empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The number to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrNotEmpty<T>(
        T value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : INumber<T>
    {
        return BuildInPredicates.NullOrNotEmpty(value)
            ? this
            : WithProblem(Rules.NullOrNotEmpty, R.NullOrNotMessageTemplate, property);
    }

    /// <summary>
    /// Validates a number to ensure that the value is null or not empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The number to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrNotEmpty<T>(
        T? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, INumber<T>
    {
        return BuildInPredicates.NullOrNotEmpty(value)
            ? this
            : WithProblem(Rules.NullOrNotEmpty, R.NullOrNotMessageTemplate, property);
    }

    #endregion

    #region Equal NotEqual

    /// <summary>
    /// Validates a string to ensure that the value is equal to the expected value.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="expected">The expected value.</param>
    /// <param name="comparison">The string comparison type.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Equal(
        string? value,
        string expected,
        StringComparison comparison = StringComparison.Ordinal,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.Equal(value, expected, comparison)
            ? this
            : WithProblem(Rules.Equals, value, R.EqualMessageTemplate, property, expected);
    }

    /// <summary>
    /// Validates a value to ensure that the value is equal to the expected value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="expected">The expected value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Equal<T>(
        T? value,
        T expected,
        [CallerArgumentExpression(nameof(value))] string? property = null) where T : IEquatable<T>
    {
        return BuildInPredicates.Equal(value, expected)
            ? this
            : WithProblem(Rules.Equals, value, R.EqualMessageTemplate, property, expected);
    }

    /// <summary>
    /// Validates a value to ensure that the value is equal to the expected value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="expected">The expected value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Equal<T>(
        T? value,
        T expected,
        [CallerArgumentExpression(nameof(value))] string? property = null) where T : struct, IEquatable<T>
    {
        return BuildInPredicates.Equal(value, expected)
            ? this
            : WithProblem(Rules.Equals, value, R.EqualMessageTemplate, property, expected);
    }

    /// <summary>
    /// Validates a string to ensure that the value is not equal to the expected value.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="expected">The expected value.</param>
    /// <param name="comparison">The string comparison type.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEqual(
        string? value, 
        string expected,
        StringComparison comparison = StringComparison.Ordinal,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEqual(value, expected, comparison)
            ? this
            : WithProblem(Rules.NotEquals, value, R.NotEqualMessageTemplate, property, expected);
    }

    /// <summary>
    /// Validates a value to ensure that the value is not equal to the expected value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="expected">The expected value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEqual<T>(
        T? value,
        T expected,
        [CallerArgumentExpression(nameof(value))] string? property = null) where T: IEquatable<T>
    {
        return BuildInPredicates.NotEqual(value, expected)
            ? this
            : WithProblem(Rules.NotEquals, value, R.NotEqualMessageTemplate, property, expected);
    }

    /// <summary>
    /// Validates a value to ensure that the value is not equal to the expected value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="expected">The expected value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEqual<T>(
        T? value,
        T expected,
        [CallerArgumentExpression(nameof(value))] string? property = null) where T : struct, IEquatable<T>
    {
        return BuildInPredicates.NotEqual(value, expected)
            ? this
            : WithProblem(Rules.NotEquals, value, R.NotEqualMessageTemplate, property, expected);
    }

    /// <summary>
    /// Validates if both values are equal.
    /// </summary>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="comparison">The string comparison type.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothEqual(
        string? value1,
        string? value2,
        StringComparison comparison = StringComparison.Ordinal,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
    {
        return BuildInPredicates.BothEqual(value1, value2, comparison)
            ? this
            : WithProblem(Rules.BothEqual, value1, value2, R.BothEqualMessageTemplate, property1, property2);
    }

    /// <summary>
    /// Validates if both values are equal.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothEqual<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null) where T : IEquatable<T>
    {
        return BuildInPredicates.BothEqual(value1, value2)
            ? this
            : WithProblem(Rules.BothEqual, value1, value2, R.BothEqualMessageTemplate, property1, property2);
    }

    /// <summary>
    /// Validates if both values are equal.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothEqual<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null) where T : struct, IEquatable<T>
    {
        return BuildInPredicates.BothEqual(value1, value2)
            ? this
            : WithProblem(Rules.BothEqual, value1, value2, R.BothEqualMessageTemplate, property1, property2);
    }

    /// <summary>
    /// Validates if both values are not equal.
    /// </summary>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="comparison">The string comparison type.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothNotEqual(
        string? value1,
        string? value2,
        StringComparison comparison = StringComparison.Ordinal,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
    {
        return BuildInPredicates.BothNotEqual(value1, value2, comparison)
            ? this
            : WithProblem(Rules.BothNotEqual, value1, value2, R.BothNotEqualMessageTemplate, property1, property2);
    }

    /// <summary>
    /// Validates if both values are not equal.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothNotEqual<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null) where T: IEquatable<T>
    {
        return BuildInPredicates.BothNotEqual(value1, value2)
            ? this
            : WithProblem(Rules.BothNotEqual, value1, value2, R.BothNotEqualMessageTemplate, property1, property2);
    }

    /// <summary>
    /// Validates if both values are not equal.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothNotEqual<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null) where T : struct, IEquatable<T>
    {
        return BuildInPredicates.BothNotEqual(value1, value2)
            ? this
            : WithProblem(Rules.BothNotEqual, value1, value2, R.BothNotEqualMessageTemplate, property1, property2);
    }

    #endregion

    #region String and Pattern

    /// <summary>
    /// Validates a string to ensure that it matches the specified regular expression pattern.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="patternDescription">Optional, a human-readable description of the pattern to use in the error message.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet Matches(
        string? value,
        string pattern,
        string? patternDescription = null,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.Matches(value, pattern)
            ? this
            : WithPatternProblem(Rules.MatchPattern, value, R.MatchesMessageTemplate, property, pattern, patternDescription);
    }

    /// <summary>
    /// Validates a string to ensure that it matches the specified regular expression.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="regex">The compiled regular expression to match.</param>
    /// <param name="patternDescription">A human-readable description of the pattern to use in the error message.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet Matches(
        string? value,
        Regex regex,
        string patternDescription,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.Matches(value, regex)
            ? this
            : WithPatternProblem(Rules.MatchPattern, value, R.MatchesMessageTemplate, property, regex.ToString(), patternDescription);
    }

    /// <summary>
    /// Validates a string to ensure that it does not match the specified regular expression pattern.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="pattern">The regular expression pattern that must not match.</param>
    /// <param name="patternDescription">Optional, a human-readable description of the pattern to use in the error message.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet NotMatches(
        string? value,
        string pattern,
        string? patternDescription = null,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotMatches(value, pattern)
            ? this
            : WithPatternProblem(Rules.NotMatchPattern, value, R.NotMatchesMessageTemplate, property, pattern, patternDescription);
    }

    /// <summary>
    /// Validates a string to ensure that it does not match the specified regular expression.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="regex">The compiled regular expression that must not match.</param>
    /// <param name="patternDescription">A human-readable description of the pattern to use in the error message.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet NotMatches(
        string? value,
        Regex regex,
        string patternDescription,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotMatches(value, regex)
            ? this
            : WithPatternProblem(Rules.NotMatchPattern, value, R.NotMatchesMessageTemplate, property, regex.ToString(), patternDescription);
    }

    /// <summary>
    /// Validates a string to ensure that it starts with the expected value.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="expectedStart">The expected starting substring.</param>
    /// <param name="comparison">The string comparison type.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet StartsWith(
        string? value,
        string expectedStart,
        StringComparison comparison = StringComparison.Ordinal,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.StartsWith(value, expectedStart, comparison)
            ? this
            : WithProblem(Rules.StartsWith, value, R.StartsWithMessageTemplate, property, expectedStart);
    }

    /// <summary>
    /// Validates a string to ensure that it ends with the expected value.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="expectedEnd">The expected ending substring.</param>
    /// <param name="comparison">The string comparison type.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet EndsWith(
        string? value,
        string expectedEnd,
        StringComparison comparison = StringComparison.Ordinal,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.EndsWith(value, expectedEnd, comparison)
            ? this
            : WithProblem(Rules.EndsWith, value, R.EndsWithMessageTemplate, property, expectedEnd);
    }

    /// <summary>
    /// Validates a string to ensure that it contains the expected substring.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="expectedSubstring">The expected substring to be contained.</param>
    /// <param name="comparison">The string comparison type.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet Contains(
        string? value,
        string expectedSubstring,
        StringComparison comparison = StringComparison.Ordinal,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.Contains(value, expectedSubstring, comparison)
            ? this
            : WithProblem(Rules.Contains, value, R.ContainsMessageTemplate, property, expectedSubstring);
    }

    /// <summary>
    /// Validates a string to ensure that it does not contain the unexpected substring.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="unexpectedSubstring">The unexpected substring that must not be contained.</param>
    /// <param name="comparison">The string comparison type.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet NotContain(
        string? value,
        string unexpectedSubstring,
        StringComparison comparison = StringComparison.Ordinal,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotContain(value, unexpectedSubstring, comparison)
            ? this
            : WithProblem(Rules.NotContain, value, R.NotContainMessageTemplate, property, unexpectedSubstring);
    }

    /// <summary>
    /// Validates a string to ensure that it contains only letter characters.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet OnlyLetters(
        string? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.OnlyLetters(value)
            ? this
            : WithProblem(Rules.OnlyLetters, value, R.OnlyLettersMessageTemplate, property);
    }

    /// <summary>
    /// Validates a string to ensure that it contains only digit characters.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet OnlyDigits(
        string? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.OnlyDigits(value)
            ? this
            : WithProblem(Rules.OnlyDigits, value, R.OnlyDigitsMessageTemplate, property);
    }

    /// <summary>
    /// Validates a string to ensure that it contains only letter or digit characters.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet OnlyLettersOrDigits(
        string? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.OnlyLettersOrDigits(value)
            ? this
            : WithProblem(Rules.OnlyLettersOrDigits, value, R.OnlyLettersOrDigitsMessageTemplate, property);
    }

    /// <summary>
    /// Validates a string to ensure that it does not contain any whitespace characters.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet NoWhiteSpace(
        string? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NoWhiteSpace(value)
            ? this
            : WithProblem(Rules.NoWhiteSpace, value, R.NoWhiteSpaceMessageTemplate, property);
    }

    #endregion

    #region Min Max

    /// <summary>
    /// Validates a value to ensure that the value is greater than or equal to the minimum value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Min<T>(T value, T min, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : IComparable<T>
    {
        return BuildInPredicates.Min(value, min)
            ? this
            : WithProblem(Rules.Min, value, R.MinMessageTemplate, property, min);
    }

    /// <summary>
    /// Validates a value to ensure that the value is greater than or equal to the minimum value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Min<T>(T? value, T min, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, IComparable<T>
    {
        return BuildInPredicates.Min(value, min)
            ? this
            : WithProblem(Rules.Min, value, R.MinMessageTemplate, property, min);
    }

    /// <summary>
    /// Validates a value to ensure that the value is greater than or equal to the minimum value, if the value is not null.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrMin<T>(T? value, T min, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, IComparable<T>
    {
        return !value.HasValue || BuildInPredicates.Min(value.Value, min)
            ? this
            : WithProblem(Rules.NullOrMin, value, R.NullOrMinMessageTemplate, property, min);
    }

    /// <summary>
    /// Validates a string to ensure that the value is greater than or equal to the minimum length.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="minLength">The minimum length.</param>
    /// <param name="property">The property name.</param>
    /// <returns>The <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet MinLength(string? value, int minLength, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.MinLength(value, minLength)
            ? this
            : WithProblem(Rules.MinLength, value, R.MinLengthMessageTemplate, property, minLength.ToString());
    }

    /// <summary>
    /// Validates a string to ensure that the value is greater than or equal to the minimum length, if the value is not null.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="minLength">The minimum length.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrMinLength(string? value, int minLength, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return value is null || BuildInPredicates.MinLength(value, minLength)
            ? this
            : WithProblem(Rules.NullOrMinLength, value, R.NullOrMinLengthMessageTemplate, property, minLength.ToString());
    }

    /// <summary>
    /// Validates a value to ensure that the value is less than or equal to the maximum value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="max">The maximum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Max<T>(T value, T max, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : IComparable<T>
    {
        return BuildInPredicates.Max(value, max)
            ? this
            : WithProblem(Rules.Max, value, R.MaxMessageTemplate, property, max);
    }

    /// <summary>
    /// Validates a value to ensure that the value is less than or equal to the maximum value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="max">The maximum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Max<T>(T? value, T max, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, IComparable<T>
    {
        return BuildInPredicates.Max(value, max)
            ? this
            : WithProblem(Rules.Max, value, R.MaxMessageTemplate, property, max);
    }

    /// <summary>
    /// Validates a value to ensure that the value is less than or equal to the maximum value, if the value is not null.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="max">The maximum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>The <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrMax<T>(T? value, T max, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, IComparable<T>
    {
        return !value.HasValue || BuildInPredicates.Max(value.Value, max)
            ? this
            : WithProblem(Rules.NullOrMax, value, R.NullOrMaxMessageTemplate, property, max);
    }

    /// <summary>
    /// Validates a string to ensure that the value is less than or equal to the maximum length.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="maxLength">The maximum length.</param>
    /// <param name="property">The property name.</param>
    /// <returns>The <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet MaxLength(string? value, int maxLength, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.MaxLength(value, maxLength)
            ? this
            : WithProblem(Rules.MaxLength, value, R.MaxLengthMessageTemplate, property, maxLength.ToString());
    }

    /// <summary>
    /// Validates a string to ensure that the value is less than or equal to the maximum length, if the value is not null.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="maxLength">The maximum length.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrMaxLength(string? value, int maxLength, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return value is null || BuildInPredicates.MaxLength(value, maxLength)
            ? this
            : WithProblem(Rules.NullOrMaxLength, value, R.NullOrMaxLengthMessageTemplate, property, maxLength.ToString());
    }

    /// <summary>
    /// Validates a value to ensure that the value is between the minimum and maximum values (inclusive).
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="max">The maximum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet MinMax<T>(T value, T min, T max, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : IComparable<T>
    {
        return BuildInPredicates.MinMax(value, min, max)
            ? this
            : WithBetweenProblem(Rules.MinMax, value, R.MinMaxMessageTemplate, property, min, max);
    }

    /// <summary>
    /// Validates a value to ensure that the value is between the minimum and maximum values (inclusive).
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="max">The maximum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet MinMax<T>(T? value, T min, T max, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, IComparable<T>
    {
        return BuildInPredicates.MinMax(value, min, max)
            ? this
            : WithBetweenProblem(Rules.MinMax, value, R.MinMaxMessageTemplate, property, min, max);
    }

    /// <summary>
    /// Validates a value to ensure that the value is between the minimum and maximum values (inclusive), if the value is not null.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="max">The maximum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrMinMax<T>(T? value, T min, T max, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, IComparable<T>
    {
        return !value.HasValue || BuildInPredicates.MinMax(value.Value, min, max)
            ? this
            : WithBetweenProblem(Rules.NullOrMinMax, value, R.NullOrMinMaxMessageTemplate, property, min, max);
    }

    /// <summary>
    /// Validates a string to ensure that the value is between the minimum and maximum lengths (inclusive).
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="minLength">The minimum length.</param>
    /// <param name="maxLength">The maximum length.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Length(string? value, int minLength, int maxLength, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.Length(value, minLength, maxLength)
            ? this
            : WithBetweenProblem(Rules.Length, value, R.LengthMessageTemplate, property, minLength.ToString(), maxLength.ToString());
    }

    /// <summary>
    /// Validates a string to ensure that the value is between the minimum and maximum lengths (inclusive), if the value is not null.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="minLength">The minimum length.</param>
    /// <param name="maxLength">The maximum length.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrLength(string? value, int minLength, int maxLength, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return value is null || BuildInPredicates.Length(value, minLength, maxLength)
            ? this
            : WithBetweenProblem(Rules.NullOrLength, value, R.NullOrLengthMessageTemplate, property, minLength.ToString(), maxLength.ToString());
    }

    #endregion

    #region Less/Greater Than Or Equal

    /// <summary>
    /// Validates if the first value is less than the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet LessThan<T>(
        T value1, 
        T value2, 
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : IComparable<T>
    {
        return BuildInPredicates.LessThan(value1, value2)
            ? this: WithProblem(Rules.LessThan, value1, value2, R.LessThanMessageTemplate, property1, property2);
    }

    /// <summary>
    /// Validates if the first value is less than the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet LessThan<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : struct, IComparable<T>
    {
        return BuildInPredicates.LessThan(value1, value2)
            ? this : WithProblem(Rules.LessThan, value1, value2, R.LessThanMessageTemplate, property1, property2);
    }

    /// <summary>
    /// Validates if the first value is less than or equal to the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet LessThanOrEqual<T>(
        T value1,
        T value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : IComparable<T>
    {
        return BuildInPredicates.LessThanOrEqual(value1, value2)
            ? this
            : WithProblem(Rules.LessThanOrEqual, value1, value2, R.LessThanOrEqualMessageTemplate, property1, property2);
    }

    /// <summary>
    /// Validates if the first value is less than or equal to the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet LessThanOrEqual<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : struct, IComparable<T>
    {
        return BuildInPredicates.LessThanOrEqual(value1, value2)
            ? this
            : WithProblem(Rules.LessThanOrEqual, value1, value2, R.LessThanOrEqualMessageTemplate, property1, property2);
    }

    /// <summary>
    /// Validates if the first value is greater than the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet GreaterThan<T>(
        T value1,
        T value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : IComparable<T>
    {
        return BuildInPredicates.GreaterThan(value1, value2)
            ? this
            : WithProblem(Rules.GreaterThan, value1, value2, R.GreaterThanMessageTemplate, property1, property2);
    }

    /// <summary>
    /// Validates if the first value is greater than the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet GreaterThan<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : struct, IComparable<T>
    {
        return BuildInPredicates.GreaterThan(value1, value2)
            ? this
            : WithProblem(Rules.GreaterThan, value1, value2, R.GreaterThanMessageTemplate, property1, property2);
    }

    /// <summary>
    /// Validates if the first value is greater than or equal to the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet GreaterThanOrEqual<T>(
        T value1,
        T value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : IComparable<T>
    {
        return BuildInPredicates.GreaterThanOrEqual(value1, value2)
            ? this
            : WithProblem(Rules.GreaterThanOrEqual, value1, value2, R.GreaterThanOrEqualMessageTemplate, property1, property2);
    }

    /// <summary>
    /// Validates if the first value is greater than or equal to the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet GreaterThanOrEqual<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : struct, IComparable<T>
    {
        return BuildInPredicates.GreaterThanOrEqual(value1, value2)
            ? this
            : WithProblem(Rules.GreaterThanOrEqual, value1, value2, R.GreaterThanOrEqualMessageTemplate, property1, property2);
    }

    #endregion

    #region Must

    /// <summary>
    /// Validates a value to ensure that the value satisfies the predicate.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="predicate">The predicate to validate.</param>
    /// <param name="messageFormatter">The message formatter.</param>
    /// <param name="ruleName">The rule name.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet Must<T>(
        T value, 
        Func<T, bool> predicate, 
        Func<string, T, string> messageFormatter,
        string? ruleName = null,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return predicate(value)
            ? this: WithCustomProblem(ruleName, value, messageFormatter, property);
    }

    /// <summary>
    /// Validates a value to ensure that the value satisfies the predicate.
    /// </summary>
    /// <typeparam name="TValue">The value type.</typeparam>
    /// <typeparam name="TParam">The parameter type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="param">The parameter to validate.</param>
    /// <param name="predicate">The predicate to validate.</param>
    /// <param name="messageFormatter">The message formatter.</param>
    /// <param name="ruleName">The rule name.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet Must<TValue, TParam>(
        TValue value,
        TParam param,
        Func<TValue, TParam, bool> predicate,
        Func<string, TValue, TParam, string> messageFormatter,
        string? ruleName = null,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return predicate(value, param)
            ? this
            : WithCustomProblem(ruleName, value, param, messageFormatter, property);
    }

    /// <summary>
    /// Validates if both values satisfy the predicate.
    /// </summary>
    /// <typeparam name="T1">The first value type.</typeparam>
    /// <typeparam name="T2">The second value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="predicate">The predicate to validate.</param>
    /// <param name="messageFormatter">The message formatter.</param>
    /// <param name="ruleName">The rule name.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet BothMust<T1, T2>(
        T1 value1,
        T2 value2,
        Func<T1, T2, bool> predicate,
        Func<string, string, T1, T2, string> messageFormatter,
        string? ruleName = null,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
    {
        return predicate(value1, value2)
            ? this
            : WithCustomProblem(ruleName, value1, value2, messageFormatter, property1, property2);
    }

    /// <summary>
    /// Validates if both values satisfy the predicate.
    /// </summary>
    /// <typeparam name="T1">The first value type.</typeparam>
    /// <typeparam name="T2">The second value type.</typeparam>
    /// <typeparam name="TParam">The parameter type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="param">The parameter to validate.</param>
    /// <param name="predicate">The predicate to validate.</param>
    /// <param name="messageFormatter">The message formatter.</param>
    /// <param name="ruleName">The rule name.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet BothMust<T1, T2, TParam>(
        T1 value1,
        T2 value2,
        TParam param,
        Func<T1, T2, TParam, bool> predicate,
        Func<string, string, T1, T2, TParam, string> messageFormatter,
        string? ruleName = null,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
    {
        return predicate(value1, value2, param)
            ? this
            : WithCustomProblem(ruleName, value1, value2, param, messageFormatter, property1, property2);
    }

    #endregion

    #region Mist

    /// <summary>
    /// <para>
    ///     Validates a string to ensure that the value is a valid email address.
    /// </para>
    /// <para>
    ///     The validation is based on the <see cref="EmailAddressAttribute"/> attribute validation.
    /// </para>
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Email(string? value, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.IsEmail(value)
            ? this
            : WithProblem(Rules.Email, value, R.EmailMessageTemplate, property);
    }

    /// <summary>
    /// <para>
    ///     Validates a string to ensure that the value is a valid URL.
    /// </para>
    /// <para>
    ///     The validation is based on the <see cref="UrlAttribute"/> attribute validation.
    /// </para>
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Url(string? value, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.IsUrl(value)
            ? this
            : WithProblem(Rules.Url, value, R.UrlMessageTemplate, property);
    }

    #endregion

    #region Nested

    /// <summary>
    /// Validates a nested value to ensure that it is not null and applies the specified nested validations.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="value">The nested value to validate.</param>
    /// <param name="nestedValidations">A function that takes the nested value and returns a collection of problems if validation fails.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNullNested<T>(
        T? value,
        Func<T, Problems?> nestedValidations,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : class
    {
        if (value is null)
            return WithNullOrEmptyProblem(property);

        return Nested(value, nestedValidations, property);
    }

    /// <summary>
    /// Validates a nested value to ensure that it is not null and applies the specified <see cref="ValidateFunc"/>.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="value">The nested value to validate.</param>
    /// <param name="validation">A function that takes the nested value and returns a validation result.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNullNested<T>(
        T? value,
        Func<T, ValidateFunc> validation,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : class
    {
        if (value is null)
            return WithNullOrEmptyProblem(property);

        return Nested(value, validation, property);
    }

    /// <summary>
    /// Validates a nested value to ensure that it is not null and applies the specified nested validations.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="value">The nested value to validate.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNullNested<T>(
        T? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : class, IValidable
    {
        if (value is null)
            return WithNullOrEmptyProblem(property);

        return Nested(value, property);
    }

    /// <summary>
    /// Validates a collection of nested values to ensure that it is not null and applies the specified nested validations.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="values">The collection of nested values to validate.</param>
    /// <param name="nestedValidations">A function that takes the nested value and returns a collection of problems if validation fails.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNullNested<T>(
        IEnumerable<T>? values,
        Func<T, Problems?> nestedValidations,
        [CallerArgumentExpression(nameof(values))] string? property = null)
        where T : class
    {
        if (values is null)
            return WithNullOrEmptyProblem(property);

        return Nested(values, nestedValidations, property);
    }

    /// <summary>
    /// Validates a collection of nested values to ensure that it is not null and applies the specified <see cref="ValidateFunc"/>.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="values">The collection of nested values to validate.</param>
    /// <param name="validation">A function that takes the nested value and returns a validation result.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNullNested<T>(
        IEnumerable<T>? values,
        Func<T, ValidateFunc> validation,
        [CallerArgumentExpression(nameof(values))] string? property = null)
        where T : class
    {
        if (values is null)
            return WithNullOrEmptyProblem(property);

        return Nested(values, validation, property);
    }

    /// <summary>
    /// Validates a collection of nested values to ensure that it is not null and applies the specified nested validations.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="values">The collection of nested values to validate.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNullNested<T>(
        IEnumerable<T>? values,
        [CallerArgumentExpression(nameof(values))] string? property = null)
        where T : class, IValidable
    {
        if (values is null)
            return WithNullOrEmptyProblem(property);

        return Nested(values, property);
    }

    /// <summary>
    /// Validates a nested value with the specified nested validations.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="value">The nested value to validate.</param>
    /// <param name="nestedValidations">A function that takes the nested value and returns a collection of problems if validation fails.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Nested<T>(
        T? value,
        Func<T, Problems?> nestedValidations,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : class
    {
        if (value is null)
            return this;

        var nestedProblems = nestedValidations(value);
        if (nestedProblems is null)
            return this;

        foreach (var problem in nestedProblems)
            problem.ChainProperty(RemovePrefix(property));

        if (problems is null)
            return new RuleSet(type, nestedProblems, propertyPrefix);

        problems.AddRange(nestedProblems);
        return new RuleSet(type, problems, propertyPrefix);
    }

    /// <summary>
    /// Validates a nested value with the <see cref="ValidateFunc"/> of the specified type.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="value">The nested value to validate.</param>
    /// <param name="validation">A function that takes the nested value and returns a validation result.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Nested<T>(
        T? value,
        Func<T, ValidateFunc> validation,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : class
    {
        if (value is not null && validation(value)(out var nestedProblems))
        {
            foreach (var problem in nestedProblems)
                problem.ChainProperty(RemovePrefix(property));

            if (problems is null)
                return new RuleSet(type, nestedProblems, propertyPrefix);

            problems.AddRange(nestedProblems);
            return new RuleSet(type, problems, propertyPrefix);
        }

        return this;
    }

    /// <summary>
    /// Validates a nested value to ensure that it is not null and implements the <see cref="IValidable"/> interface.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="value">The nested value to validate.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Nested<T>(
        T? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : class, IValidable
    {
        if (value is not null && value.HasProblems(out var nestedProblems))
        {
            foreach (var problem in nestedProblems)
                problem.ChainProperty(property);

            if (problems is null)
                return new RuleSet(type, nestedProblems, propertyPrefix);

            problems.AddRange(nestedProblems);
            return new RuleSet(type, problems, propertyPrefix);
        }

        return this;
    }

    /// <summary>
    /// Validates a collection of nested values with the specified nested validations.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="values">The collection of nested values to validate.</param>
    /// <param name="nestedValidations">A function that takes the nested value and returns a collection of problems if validation fails.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Nested<T>(
        IEnumerable<T>? values,
        Func<T, Problems?> nestedValidations,
        [CallerArgumentExpression(nameof(values))] string? property = null)
        where T : class
    {
        if (values is null)
            return this;

        Problems? allProblems = problems;

        int index = -1;
        foreach (var value in values)
        {
            index++;

            var nestedProblems = nestedValidations(value);
            if (nestedProblems is null)
                continue;

            foreach (var problem in nestedProblems)
                problem.ChainProperty(RemovePrefix(property), index);

            if (allProblems is null)
                allProblems = nestedProblems;
            else
                allProblems.AddRange(nestedProblems);
        }

        if (allProblems is null)
            return this;

        return new RuleSet(type, allProblems, propertyPrefix);
    }

    /// <summary>
    /// Validates a collection of nested values with the <see cref="ValidateFunc"/> of the specified type.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="values">The collection of nested values to validate.</param>
    /// <param name="validation">A function that takes the nested value and returns a validation result.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Nested<T>(
        IEnumerable<T>? values,
        Func<T, ValidateFunc> validation,
        [CallerArgumentExpression(nameof(values))] string? property = null)
        where T : class
    {
        if (values is null)
            return this;

        Problems? allProblems = problems;

        int index = 0;
        foreach (var value in values)
        {
            if (value is not null && validation(value)(out var nestedProblems))
            {
                foreach (var problem in nestedProblems)
                    problem.ChainProperty(RemovePrefix(property), index);

                if (allProblems is null)
                    allProblems = nestedProblems;
                else
                    allProblems.AddRange(nestedProblems);
            }
            index++;
        }

        if (allProblems is null)
            return this;

        return new RuleSet(type, allProblems, propertyPrefix);
    }

    /// <summary>
    /// Validates a collection of nested values to ensure that they are not null and implement the <see cref="IValidable"/> interface.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="values">The collection of nested values to validate.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Nested<T>(
        IEnumerable<T>? values,
        [CallerArgumentExpression(nameof(values))] string? property = null)
        where T : class, IValidable
    {
        if (values is null)
            return this;

        var allProblems = problems;

        int index = 0;
        foreach (var value in values)
        {
            if (value is not null && value.HasProblems(out var nestedProblems))
            {
                foreach (var problem in nestedProblems)
                    problem.ChainProperty(property, index);

                if (allProblems is null)
                    allProblems = nestedProblems;
                else
                    allProblems.AddRange(nestedProblems);
            }
            index++;
        }

        if (allProblems is null)
            return this;

        return new RuleSet(type, allProblems, propertyPrefix);
    }


    #endregion

    #region Validate

    /// <summary>
    /// Validates a struct value to ensure, and implements the <see cref="IValidable"/> interface.
    /// </summary>
    /// <typeparam name="T">The type of the struct value.</typeparam>
    /// <param name="value">The struct value to validate.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Validate<T>(
        T value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, IValidable
    {
        if (value.HasProblems(out var nestedProblems))
        {
            nestedProblems.ForEach(RemovePrefix(property), (param, prop) => prop.ReplaceProperty(param));

            if (problems is null)
                return new RuleSet(type, nestedProblems, propertyPrefix);

            problems.AddRange(nestedProblems);
            return new RuleSet(type, problems, propertyPrefix);
        }

        return this;
    }

    /// <summary>
    /// Validates a collection of struct values to ensure, and implements the <see cref="IValidable"/> interface.
    /// </summary>
    /// <typeparam name="T">The type of the struct value.</typeparam>
    /// <param name="values">The collection of struct values to validate.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Validate<T>(
        IEnumerable<T>? values,
        [CallerArgumentExpression(nameof(values))] string? property = null)
        where T : struct, IValidable
    {
        if (values is null)
            return this;

        var allProblems = problems;

        int index = 0;
        foreach (var value in values)
        {
            if (value.HasProblems(out var nestedProblems))
            {
                nestedProblems.ForEach(RemovePrefix(property), (param, prop) => prop.ReplaceProperty($"{param}[{index}]"));

                if (allProblems is null)
                    allProblems = nestedProblems;
                else
                    allProblems.AddRange(nestedProblems);
            }
            index++;
        }

        if (allProblems is null)
            return this;

        return new RuleSet(type, allProblems, propertyPrefix);
    }

    #endregion

    #region When/Unless

    /// <summary>
    /// Conditionally applies a set of rules to the current <see cref="RuleSet"/>.
    /// </summary>
    /// <param name="condition">
    /// When <see langword="true"/>, the <paramref name="ruleSetBuilder"/> is executed against the current
    /// <see cref="RuleSet"/>; otherwise, the current <see cref="RuleSet"/> is returned unchanged.
    /// </param>
    /// <param name="ruleSetBuilder">
    /// A function that receives the current <see cref="RuleSet"/> and returns a <see cref="RuleSet"/> with
    /// potential problems appended.
    /// </param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet When(bool condition, RuleSetBuilder ruleSetBuilder)
    {
        return condition ? ruleSetBuilder(this) : this;
    }

    /// <summary>
    /// Applies the provided rules unless the <paramref name="condition"/> is <see langword="true"/>.
    /// </summary>
    /// <param name="condition">
    /// When <see langword="true"/>, no rules are applied and the current <see cref="RuleSet"/> is returned;
    /// when <see langword="false"/>, the <paramref name="ruleSetBuilder"/> is executed against the current
    /// <see cref="RuleSet"/>.
    /// </param>
    /// <param name="ruleSetBuilder">
    /// A function that receives the current <see cref="RuleSet"/> and returns a <see cref="RuleSet"/> with
    /// potential problems appended.
    /// </param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Unless(bool condition, RuleSetBuilder ruleSetBuilder)
    {
        return condition ? this : ruleSetBuilder(this);
    }

    /// <summary>
    /// Applies an alternative set of rules unless the condition rules succeed.
    /// Both rule groups are evaluated in isolation (using a new <see cref="RuleSet"/> that shares the same type and property prefix).
    /// If both groups produce problems, the problems from both groups are added to the current <see cref="RuleSet"/>; otherwise, no problems are added.
    /// </summary>
    /// <param name="conditionRules">The rules representing the condition to suppress the alternative rules.</param>
    /// <param name="alternativeRules">The alternative rules to apply when the condition rules do not pass.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Unless(RuleSetBuilder conditionRules, RuleSetBuilder alternativeRules)
    {
        if (conditionRules(new RuleSet(type, null, propertyPrefix)).HasProblems(out var condProblems)
            && alternativeRules(new RuleSet(type, null, propertyPrefix)).HasProblems(out var altProblems))
        {
            return WithProblems(condProblems, altProblems);
        }

        return this;
    }

    /// <summary>
    /// Uses pre-evaluated rule groups with the same semantics as other <c>Unless</c> overloads.
    /// If both the <paramref name="conditionRules"/> and <paramref name="alternativeRules"/> contain problems,
    /// the problems from both are added to the current <see cref="RuleSet"/>; otherwise, no problems are added.
    /// </summary>
    /// <param name="conditionRules">The already evaluated condition rule group.</param>
    /// <param name="alternativeRules">The already evaluated alternative rule group.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Unless(RuleSet conditionRules, RuleSet alternativeRules)
    {
        if (conditionRules.HasProblems(out var condProblems)
            && alternativeRules.HasProblems(out var altProblems))
        {
            return WithProblems(condProblems, altProblems);
        }

        return this;
    }

    /// <summary>
    /// Applies an alternative rule group produced by a factory unless the condition rule group (already evaluated) succeeds.
    /// If both groups produce problems, their problems are added to the current <see cref="RuleSet"/>; otherwise, no problems are added.
    /// </summary>
    /// <param name="conditionRules">The already evaluated condition rule group.</param>
    /// <param name="alternativeRules">A factory that produces the alternative rule group.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Unless(RuleSet conditionRules, RuleSetFactory alternativeRules)
    {
        if (conditionRules.HasProblems(out var condProblems)
            && alternativeRules().HasProblems(out var altProblems))
        {
            return WithProblems(condProblems, altProblems);
        }

        return this;
    }

    /// <summary>
    /// Applies an alternative rule group built from the current context unless the condition rule group (already evaluated) succeeds.
    /// If both groups produce problems, their problems are added to the current <see cref="RuleSet"/>; otherwise, no problems are added.
    /// </summary>
    /// <param name="conditionRules">The already evaluated condition rule group.</param>
    /// <param name="alternativeRules">A builder executed against a fresh <see cref="RuleSet"/> with the same type and property prefix.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Unless(RuleSet conditionRules, RuleSetBuilder alternativeRules)
    {
        if (conditionRules.HasProblems(out var condProblems)
            && alternativeRules(new RuleSet(type, null, propertyPrefix)).HasProblems(out var altProblems))
        {
            return WithProblems(condProblems, altProblems);
        }

        return this;
    }

    /// <summary>
    /// Applies an alternative rule group produced by a factory unless the condition rule group (also produced by a factory) succeeds.
    /// Both groups are evaluated in isolation; if both produce problems, their problems are added to the current <see cref="RuleSet"/>;
    /// otherwise, no problems are added.
    /// </summary>
    /// <param name="conditionRules">A factory that produces the condition rule group.</param>
    /// <param name="alternativeRules">A factory that produces the alternative rule group.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Unless(RuleSetFactory conditionRules, RuleSetFactory alternativeRules)
    {
        if (conditionRules().HasProblems(out var condProblems)
            && alternativeRules().HasProblems(out var altProblems))
        {
            return WithProblems(condProblems, altProblems);
        }

        return this;
    }

    /// <summary>
    /// Applies an alternative rule group built from the current context unless the condition rule group produced by a factory succeeds.
    /// Both groups are evaluated in isolation; if both produce problems, their problems are added to the current <see cref="RuleSet"/>;
    /// otherwise, no problems are added.
    /// </summary>
    /// <param name="conditionRules">A factory that produces the condition rule group.</param>
    /// <param name="alternativeRules">A builder executed against a fresh <see cref="RuleSet"/> with the same type and property prefix.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Unless(RuleSetFactory conditionRules, RuleSetBuilder alternativeRules)
    {
        if (conditionRules().HasProblems(out var condProblems)
            && alternativeRules(new RuleSet(type, null, propertyPrefix)).HasProblems(out var altProblems))
        {
            return WithProblems(condProblems, altProblems);
        }

        return this;
    }

    #endregion

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet WithNullOrEmptyProblem(string? property)
    {
        GetPropertyNameAndDisplayName(property, out var propertyName, out var displayName);

        return WithProblem(
            Problems.InvalidParameter(string.Format(R.NotNullOrEmptyMessageTemplate, displayName), propertyName)
                .With(Rules.RuleProperty, Rules.NotNullOrNotEmpty));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet WithPatternProblem(string rule, string? value, string messageTemplate, string? property, string pattern, string? patternDescription)
    {
        GetPropertyNameAndDisplayName(property, out var propertyName, out var displayName);

        return WithProblem(
            Problems.InvalidParameter(string.Format(messageTemplate, displayName, patternDescription ?? pattern), propertyName)
                .With(Rules.RuleProperty, rule)
                .With(Rules.PatternProperty, pattern)
                .With(Rules.CurrentValueProperty, value));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet WithProblem(string rule, string messageTemplate, string? property)
    {
        GetPropertyNameAndDisplayName(property, out var propertyName, out var displayName);

        return WithProblem(
            Problems.InvalidParameter(string.Format(messageTemplate, displayName), propertyName)
                .With(Rules.RuleProperty, rule));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet WithProblem<T>(string rule, T value, string messageTemplate, string? property)
    {
        GetPropertyNameAndDisplayName(property, out var propertyName, out var displayName);

        return WithProblem(
            Problems.InvalidParameter(string.Format(messageTemplate, displayName), propertyName)
                .With(Rules.RuleProperty, rule)
                .With(Rules.CurrentValueProperty, value));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet WithProblem<T>(string rule, T value, string messageTemplate, string? property, T expected)
    {
        GetPropertyNameAndDisplayName(property, out var propertyName, out var displayName);

        return WithProblem(
            Problems.InvalidParameter(string.Format(messageTemplate, displayName, expected), propertyName)
                .With(Rules.RuleProperty, rule)
                .With(Rules.CurrentValueProperty, value)
                .With(Rules.ExpectedValueProperty, expected));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet WithBetweenProblem<T>(string rule, T value, string messageTemplate, string? property, T expected1, T expected2)
    {
        GetPropertyNameAndDisplayName(property, out var propertyName, out var displayName);

        return WithProblem(
            Problems.InvalidParameter(string.Format(messageTemplate, displayName, expected1, expected2), propertyName)
                .With(Rules.RuleProperty, rule)
                .With(Rules.CurrentValueProperty, value)
                .With(Rules.ExpectedValueProperty, new T[] { expected1, expected2 }));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet WithProblem<T>(string rule, T value1, T value2, string messageTemplate, string? property1, string? property2)
    {
        GetPropertyNameAndDisplayName(property1, out var property1Name, out var displayName1);
        GetPropertyNameAndDisplayName(property2, out var property2Name, out var displayName2);

        return WithProblem(
            Problems.InvalidParameter(string.Format(messageTemplate, displayName1, displayName2))
                .With(Rules.RuleProperty, rule)
                .With("properties", new string?[] { property1Name, property2Name })
                .With("values", new T[] { value1, value2 }));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet WithCustomProblem<T>(string? rule, T value, Func<string, T, string> messageFormatter, string? property)
    {
        GetPropertyNameAndDisplayName(property, out var propertyName, out var displayName);

        var problem = Problems.InvalidParameter(messageFormatter(displayName, value), propertyName);

        if (rule is not null)
            problem.With(Rules.RuleProperty, rule);

        problem.With(Rules.CurrentValueProperty, value);

        return WithProblem(problem);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet WithCustomProblem<T, P>(string? rule, T value, P param, Func<string, T, P, string> messageFormatter, string? property)
    {
        GetPropertyNameAndDisplayName(property, out var propertyName, out var displayName);

        var problem = Problems.InvalidParameter(messageFormatter(displayName, value, param), propertyName);

        if (rule is not null)
            problem.With(Rules.RuleProperty, rule);

        problem.With(Rules.CurrentValueProperty, value);

        return WithProblem(problem);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet WithCustomProblem<T1, T2>(string? rule, T1 value1, T2 value2, Func<string, string, T1, T2, string> messageFormatter, string? property1, string? property2)
    {
        GetPropertyNameAndDisplayName(property1, out var property1Name, out var displayName1);
        GetPropertyNameAndDisplayName(property2, out var property2Name, out var displayName2);

        var problem = Problems.InvalidParameter(messageFormatter(displayName1, displayName2, value1, value2));

        if (rule is not null)
            problem.With(Rules.RuleProperty, rule);

        problem.With("properties", new string?[] { property1Name, property2Name })
            .With("values", new object?[] { value1, value2 });

        return WithProblem(problem);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet WithCustomProblem<T1, T2, P>(string? rule, T1 value1, T2 value2, P param, Func<string, string, T1, T2, P, string> messageFormatter, string? property1, string? property2)
    {
        GetPropertyNameAndDisplayName(property1, out var property1Name, out var displayName1);
        GetPropertyNameAndDisplayName(property2, out var property2Name, out var displayName2);

        var problem = Problems.InvalidParameter(messageFormatter(displayName1, displayName2, value1, value2, param));

        if (rule is not null)
            problem.With(Rules.RuleProperty, rule);

        problem.With("properties", new string?[] { property1Name, property2Name })
            .With("values", new object?[] { value1, value2 });

        return WithProblem(problem);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet WithProblems(Problems problems1, Problems problems2)
    {
        var allProblems = problems ?? [];
        allProblems.AddRange(problems1);
        allProblems.AddRange(problems2);
        return new RuleSet(type, allProblems, propertyPrefix);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private string? RemovePrefix(string? property)
    {
        if (propertyPrefix is not null && property is not null && property.StartsWith($"{propertyPrefix}."))
            return property[(propertyPrefix.Length + 1)..];

        return property;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private string GetDisplayName(string? propertyName)
    {
        return DisplayNames.Instance.GetDisplayName(type, propertyName);
    }

    
}
