using System.ComponentModel.DataAnnotations;
using System.Diagnostics.CodeAnalysis;
using System.Numerics;
using System.Runtime.CompilerServices;
using RoyalCode.SmartProblems;
using RoyalCode.SmartProblems.Entities;

namespace RoyalCode.SmartValidations;

/// <summary>
/// Struct to apply validation rules and collect the result.
/// </summary>
public readonly ref struct RuleSet
{
    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)]
    private readonly Type? type;
    private readonly Problems? problems;
    private readonly string? propertyPrefix;

    /// <summary>
    /// Implicit conversion from <see cref="RuleSet"/> to <see cref="Problems"/>.
    /// </summary>
    /// <param name="set"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Problems?(RuleSet set) => set.problems;

    /// <summary>
    /// Create a new rule set for a model to apply validation rules.
    /// </summary>
    /// <typeparam name="T">The model type to validate.</typeparam>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public static RuleSet For<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)]T>() => new(typeof(T));

    /// <summary>
    /// Initialize a <see cref="RuleSet"/>.
    /// </summary>
    /// <param name="type">The type being validated.</param>
    /// <param name="problems">The problems found, if any.</param>
    /// <param name="propertyPrefix">Optional, a prefix of the property name to be removed.</param>
    private RuleSet(
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] Type? type = null,
        Problems? problems = null,
        string? propertyPrefix = null)
    {
        this.type = type;
        this.problems = problems;
        this.propertyPrefix = propertyPrefix;
    }

    /// <summary>
    /// Add a problem to the rule set.
    /// </summary>
    /// <param name="problem">The problem to add.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet WithProblem(Problem problem)
    {
        Problems resultProblems = problems ?? [];
        resultProblems.Add(problem);
        return new RuleSet(type, resultProblems, propertyPrefix);
    }

    /// <summary>
    /// Creates a new <see cref="RuleSet"/> with the specified property prefix appended to the current prefix.
    /// </summary>
    /// <param name="propertyPrefix">The property prefix to append. Cannot be <see langword="null"/>.</param>
    /// <returns>A new <see cref="RuleSet"/> with the updated property prefix.</returns>
    public RuleSet WithPropertyPrefix(string propertyPrefix)
    {
        ArgumentNullException.ThrowIfNull(propertyPrefix);

        var propPrefix = this.propertyPrefix is null
            ? propertyPrefix
            : $"{this.propertyPrefix}.{propertyPrefix}";

        return new RuleSet(type, problems, propPrefix);
    }

    /// <summary>
    /// <para>
    ///     Get the display name of a property.
    /// </para>
    /// <para>
    ///     Useful to get the display name of a property in a model when creating custom messages for custom rules.
    /// </para>
    /// </summary>
    /// <param name="property"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public string GetDisplayName(string? property)
    {
        return DisplayNames.Instance.GetDisplayName(type, RemovePrefix(property));
    }

    /// <summary>
    /// Check if the rule set has any problems.
    /// </summary>
    /// <param name="problems">The problems generated by the rules.</param>
    /// <returns>True if the rule set has problems, false otherwise.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool HasProblems([NotNullWhen(true)] out Problems? problems)
    {
        problems = this.problems;
        return problems is not null;
    }

    #region Not Null

    /// <summary>
    /// Validates a value to ensure that the value is not null.
    /// </summary>
    /// <typeparam name="TValue">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNull<TValue>(
        [NotNullWhen(true)] TValue value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return value is not null 
            ? this 
            : NullOrEmptyProblem(property);
    }

    #endregion

    #region Not Empty

    /// <summary>
    /// Validates a string to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        [NotNullWhen(true)] string? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value) 
            ? this 
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a number to ensure that the value is not null or empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty<T>(
        [NotNullWhen(true)] T value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T: INumber<T>
    {
        return BuildInPredicates.NotEmpty(value)
            ? this 
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a number to ensure that the value is not null or empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty<T>(
        [NotNullWhen(true)] T? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, INumber<T>
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a collection to ensure that the value is not null or empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The collection to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty<T>(
        [NotNullWhen(true)] T[]? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a collection to ensure that the value is not null or empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The collection to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty<T>(
        [NotNullWhen(true)] ICollection<T>? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a collection to ensure that the value is not null or empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The collection to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty<T>(
        [NotNullWhen(true)] IEnumerable<T>? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="DateTime"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="DateTime"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        DateTime value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this 
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="DateTime"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="DateTime"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        [NotNullWhen(true)] DateTime? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="DateTimeOffset"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="DateTimeOffset"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        DateTimeOffset value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="DateTimeOffset"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="DateTimeOffset"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        [NotNullWhen(true)] DateTimeOffset? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="DateOnly"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="DateOnly"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        DateOnly value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="DateOnly"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="DateOnly"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        [NotNullWhen(true)] DateOnly? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="Guid"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="Guid"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        Guid value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates a <see cref="Guid"/> to ensure that the value is not null or empty.
    /// </summary>
    /// <param name="value">The <see cref="Guid"/> value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEmpty(
        [NotNullWhen(true)] Guid? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NotEmpty(value)
            ? this
            : NullOrEmptyProblem(property);
    }

    /// <summary>
    /// Validates if both values are null or, when one is filled, if both are not empty.
    /// </summary>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothNullOrNotEmpty(
        [NotNullWhen(true)] string? value1,
        [NotNullWhen(true)] string? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
    {
        if (BuildInPredicates.BothNullOrNotEmpty(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.BothNullOrNotMessageTemplate, property1Name, property2Name)));
    }

    #endregion

    #region Null Or Not Empty

    /// <summary>
    /// Validates a value to ensure that the value is null or not empty.
    /// </summary>
    /// <param name="value">The value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrNotEmpty(
        string? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        return BuildInPredicates.NullOrNotEmpty(value)
            ? this
            : WithProblem(Problems.InvalidParameter(string.Format(R.NullOrNotMessageTemplate, property)));
    }

    /// <summary>
    /// Validates a number to ensure that the value is null or not empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The number to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrNotEmpty<T>(
        T value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : INumber<T>
    {
        return BuildInPredicates.NullOrNotEmpty(value)
            ? this
            : WithProblem(Problems.InvalidParameter(string.Format(R.NullOrNotMessageTemplate, property)));
    }

    /// <summary>
    /// Validates a number to ensure that the value is null or not empty.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The number to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrNotEmpty<T>(
        T? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, INumber<T>
    {
        return BuildInPredicates.NullOrNotEmpty(value)
            ? this
            : WithProblem(Problems.InvalidParameter(
                string.Format(R.NullOrNotMessageTemplate, property)));
    }

    #endregion

    #region Equal NotEqual

    /// <summary>
    /// Validates a string to ensure that the value is equal to the expected value.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="expected">The expected value.</param>
    /// <param name="comparison">The string comparison type.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Equal(
        string? value,
        string expected,
        StringComparison comparison = StringComparison.Ordinal,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        if (BuildInPredicates.Equal(value, expected, comparison))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.EqualMessageTemplate, propertyName, expected), property));
    }

    /// <summary>
    /// Validates a value to ensure that the value is equal to the expected value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="expected">The expected value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Equal<T>(
        T? value,
        T expected,
        [CallerArgumentExpression(nameof(value))] string? property = null) where T : IEquatable<T>
    {
        if (BuildInPredicates.Equal(value, expected))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.EqualMessageTemplate, propertyName, expected), property));
    }

    /// <summary>
    /// Validates a value to ensure that the value is equal to the expected value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="expected">The expected value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Equal<T>(
        T? value,
        T expected,
        [CallerArgumentExpression(nameof(value))] string? property = null) where T : struct, IEquatable<T>
    {
        if (BuildInPredicates.Equal(value, expected))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.EqualMessageTemplate, propertyName, expected), property));
    }

    /// <summary>
    /// Validates a string to ensure that the value is not equal to the expected value.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="expected">The expected value.</param>
    /// <param name="comparison">The string comparison type.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEqual(
        string? value, 
        string expected,
        StringComparison comparison = StringComparison.Ordinal,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        if (BuildInPredicates.NotEqual(value, expected, comparison))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.NotEqualMessageTemplate, propertyName, expected), property));
    }

    /// <summary>
    /// Validates a value to ensure that the value is not equal to the expected value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="expected">The expected value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEqual<T>(
        T? value,
        T expected,
        [CallerArgumentExpression(nameof(value))] string? property = null) where T: IEquatable<T>
    {
        if (BuildInPredicates.NotEqual(value, expected))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.NotEqualMessageTemplate, propertyName, expected), property));
    }

    /// <summary>
    /// Validates a value to ensure that the value is not equal to the expected value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="expected">The expected value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotEqual<T>(
        T? value,
        T expected,
        [CallerArgumentExpression(nameof(value))] string? property = null) where T : struct, IEquatable<T>
    {
        if (BuildInPredicates.NotEqual(value, expected))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.NotEqualMessageTemplate, propertyName, expected), property));
    }

    /// <summary>
    /// Validates if both values are equal.
    /// </summary>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="comparison">The string comparison type.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothEqual(
        string? value1,
        string? value2,
        StringComparison comparison = StringComparison.Ordinal,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
    {
        if (BuildInPredicates.BothEqual(value1, value2, comparison))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.BothEqualMessageTemplate, property1Name, property2Name)));
    }

    /// <summary>
    /// Validates if both values are equal.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothEqual<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null) where T : IEquatable<T>
    {
        if (BuildInPredicates.BothEqual(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.BothEqualMessageTemplate, property1Name, property2Name)));
    }

    /// <summary>
    /// Validates if both values are equal.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothEqual<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null) where T : struct, IEquatable<T>
    {
        if (BuildInPredicates.BothEqual(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.BothEqualMessageTemplate, property1Name, property2Name)));
    }

    /// <summary>
    /// Validates if both values are not equal.
    /// </summary>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="comparison">The string comparison type.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothNotEqual(
        string? value1,
        string? value2,
        StringComparison comparison = StringComparison.Ordinal,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
    {
        if (BuildInPredicates.BothNotEqual(value1, value2, comparison))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.BothNotEqualMessageTemplate, property1Name, property2Name)));
    }

    /// <summary>
    /// Validates if both values are not equal.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothNotEqual<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null) where T: IEquatable<T>
    {
        if (BuildInPredicates.BothNotEqual(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.BothNotEqualMessageTemplate, property1Name, property2Name)));
    }

    /// <summary>
    /// Validates if both values are not equal.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet BothNotEqual<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null) where T : struct, IEquatable<T>
    {
        if (BuildInPredicates.BothNotEqual(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.BothNotEqualMessageTemplate, property1Name, property2Name)));
    }

    #endregion

    #region Min Max

    /// <summary>
    /// Validates a value to ensure that the value is greater than or equal to the minimum value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Min<T>(T value, T min, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : IComparable<T>
    {
        if (BuildInPredicates.Min(value, min))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.MinMessageTemplate, propertyName, min.ToString()), property));
    }

    /// <summary>
    /// Validates a value to ensure that the value is greater than or equal to the minimum value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Min<T>(T? value, T min, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, IComparable<T>
    {
        if (BuildInPredicates.Min(value, min))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.MinMessageTemplate, propertyName, min.ToString()), property));
    }

    /// <summary>
    /// Validates a value to ensure that the value is greater than or equal to the minimum value, if the value is not null.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrMin<T>(T? value, T min, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, IComparable<T>
    {
        if (!value.HasValue || BuildInPredicates.Min(value.Value, min))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.NullOrMinMessageTemplate, propertyName, min.ToString()), property));
    }

    /// <summary>
    /// Validates a string to ensure that the value is greater than or equal to the minimum length.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="minLength">The minimum length.</param>
    /// <param name="property">The property name.</param>
    /// <returns>The <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet MinLength(string? value, int minLength, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        if (BuildInPredicates.MinLength(value, minLength))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.MinLengthMessageTemplate, propertyName, minLength.ToString()), property));
    }

    /// <summary>
    /// Validates a string to ensure that the value is greater than or equal to the minimum length, if the value is not null.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="minLength">The minimum length.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrMinLength(string? value, int minLength, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        if (value is null || BuildInPredicates.MinLength(value, minLength))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.NullOrMinLengthMessageTemplate, propertyName, minLength.ToString()), property));
    }

    /// <summary>
    /// Validates a value to ensure that the value is less than or equal to the maximum value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="max">The maximum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Max<T>(T value, T max, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : IComparable<T>
    {
        if (BuildInPredicates.Max(value, max))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.MaxMessageTemplate, propertyName, max.ToString()), property));
    }

    /// <summary>
    /// Validates a value to ensure that the value is less than or equal to the maximum value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="max">The maximum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Max<T>(T? value, T max, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, IComparable<T>
    {
        if (BuildInPredicates.Max(value, max))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.MaxMessageTemplate, propertyName, max.ToString()), property));
    }

    /// <summary>
    /// Validates a value to ensure that the value is less than or equal to the maximum value, if the value is not null.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="max">The maximum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>The <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrMax<T>(T? value, T max, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, IComparable<T>
    {
        if (!value.HasValue || BuildInPredicates.Max(value.Value, max))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.NullOrMaxMessageTemplate, propertyName, max.ToString()), property));
    }

    /// <summary>
    /// Validates a string to ensure that the value is less than or equal to the maximum length.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="maxLength">The maximum length.</param>
    /// <param name="property">The property name.</param>
    /// <returns>The <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet MaxLength(string? value, int maxLength, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        if (BuildInPredicates.MaxLength(value, maxLength))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.MaxLengthMessageTemplate, propertyName, maxLength.ToString()), property));
    }

    /// <summary>
    /// Validates a string to ensure that the value is less than or equal to the maximum length, if the value is not null.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="maxLength">The maximum length.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrMaxLength(string? value, int maxLength, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        if (value is null || BuildInPredicates.MaxLength(value, maxLength))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.NullOrMaxLengthMessageTemplate, propertyName, maxLength.ToString()), property));
    }

    /// <summary>
    /// Validates a value to ensure that the value is between the minimum and maximum values (inclusive).
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="max">The maximum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet MinMax<T>(T value, T min, T max, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : IComparable<T>
    {
        if (BuildInPredicates.MinMax(value, min, max))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.MinMaxMessageTemplate, propertyName, min.ToString(), max.ToString()), property));
    }

    /// <summary>
    /// Validates a value to ensure that the value is between the minimum and maximum values (inclusive).
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="max">The maximum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet MinMax<T>(T? value, T min, T max, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, IComparable<T>
    {
        if (BuildInPredicates.MinMax(value, min, max))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.MinMaxMessageTemplate, propertyName, min.ToString(), max.ToString()), property));
    }

    /// <summary>
    /// Validates a value to ensure that the value is between the minimum and maximum values (inclusive), if the value is not null.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="min">The minimum value.</param>
    /// <param name="max">The maximum value.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrMinMax<T>(T? value, T min, T max, [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : struct, IComparable<T>
    {
        if (!value.HasValue || BuildInPredicates.MinMax(value.Value, min, max))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.NullOrMinMaxMessageTemplate, propertyName, min.ToString(), max.ToString()), property));
    }

    /// <summary>
    /// Validates a string to ensure that the value is between the minimum and maximum lengths (inclusive).
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="minLength">The minimum length.</param>
    /// <param name="maxLength">The maximum length.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Length(string? value, int minLength, int maxLength, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        if (BuildInPredicates.Length(value, minLength, maxLength))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.LengthMessageTemplate, propertyName, minLength.ToString(), maxLength.ToString()), property));
    }

    /// <summary>
    /// Validates a string to ensure that the value is between the minimum and maximum lengths (inclusive), if the value is not null.
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="minLength">The minimum length.</param>
    /// <param name="maxLength">The maximum length.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NullOrLength(string? value, int minLength, int maxLength, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        if (value is null || BuildInPredicates.Length(value, minLength, maxLength))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.NullOrLengthMessageTemplate, propertyName, minLength.ToString(), maxLength.ToString()), property));
    }

    #endregion

    #region Less/Greater Than Or Equal

    /// <summary>
    /// Validates if the first value is less than the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet LessThan<T>(
        T value1, 
        T value2, 
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : IComparable<T>
    {
        if (BuildInPredicates.LessThan(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.LessThanMessageTemplate, property1Name, property2Name)));
    }

    /// <summary>
    /// Validates if the first value is less than the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet LessThan<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : struct, IComparable<T>
    {
        if (BuildInPredicates.LessThan(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.LessThanMessageTemplate, property1Name, property2Name)));
    }

    /// <summary>
    /// Validates if the first value is less than or equal to the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet LessThanOrEqual<T>(
        T value1,
        T value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : IComparable<T>
    {
        if (BuildInPredicates.LessThanOrEqual(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.LessThanOrEqualMessageTemplate, property1Name, property2Name)));
    }

    /// <summary>
    /// Validates if the first value is less than or equal to the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet LessThanOrEqual<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : struct, IComparable<T>
    {
        if (BuildInPredicates.LessThanOrEqual(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.LessThanOrEqualMessageTemplate, property1Name, property2Name)));
    }

    /// <summary>
    /// Validates if the first value is greater than the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet GreaterThan<T>(
        T value1,
        T value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : IComparable<T>
    {
        if (BuildInPredicates.GreaterThan(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.GreaterThanMessageTemplate, property1Name, property2Name)));
    }

    /// <summary>
    /// Validates if the first value is greater than the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet GreaterThan<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : struct, IComparable<T>
    {
        if (BuildInPredicates.GreaterThan(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.GreaterThanMessageTemplate, property1Name, property2Name)));
    }

    /// <summary>
    /// Validates if the first value is greater than or equal to the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet GreaterThanOrEqual<T>(
        T value1,
        T value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : IComparable<T>
    {
        if (BuildInPredicates.GreaterThanOrEqual(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.GreaterThanOrEqualMessageTemplate, property1Name, property2Name)));
    }

    /// <summary>
    /// Validates if the first value is greater than or equal to the second value.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet GreaterThanOrEqual<T>(
        T? value1,
        T? value2,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
        where T : struct, IComparable<T>
    {
        if (BuildInPredicates.GreaterThanOrEqual(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.GreaterThanOrEqualMessageTemplate, property1Name, property2Name)));
    }

    #endregion

    #region Must

    /// <summary>
    /// Validates a value to ensure that the value satisfies the predicate.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="predicate">The predicate to validate.</param>
    /// <param name="messageFormatter">The message formatter.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet Must<T>(
        T value, 
        Func<T, bool> predicate, 
        Func<string, T, string> messageFormatter,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        if (predicate(value)) 
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(messageFormatter(propertyName, value), property));
    }

    /// <summary>
    /// Validates a value to ensure that the value satisfies the predicate.
    /// </summary>
    /// <typeparam name="TValue">The value type.</typeparam>
    /// <typeparam name="TParam">The parameter type.</typeparam>
    /// <param name="value">The value to validate.</param>
    /// <param name="param">The parameter to validate.</param>
    /// <param name="predicate">The predicate to validate.</param>
    /// <param name="messageFormatter">The message formatter.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet Must<TValue, TParam>(
        TValue value,
        TParam param,
        Func<TValue, TParam, bool> predicate,
        Func<string, TValue, TParam, string> messageFormatter,
        [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        if (predicate(value, param))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(messageFormatter(propertyName, value, param), property));
    }

    /// <summary>
    /// Validates if both values satisfy the predicate.
    /// </summary>
    /// <typeparam name="T1">The first value type.</typeparam>
    /// <typeparam name="T2">The second value type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="predicate">The predicate to validate.</param>
    /// <param name="messageFormatter">The message formatter.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet BothMust<T1, T2>(
        T1 value1,
        T2 value2,
        Func<T1, T2, bool> predicate,
        Func<string, string, T1, T2, string> messageFormatter,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
    {
        if (predicate(value1, value2))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(messageFormatter(property1Name, property2Name, value1, value2)));
    }

    /// <summary>
    /// Validates if both values satisfy the predicate.
    /// </summary>
    /// <typeparam name="T1">The first value type.</typeparam>
    /// <typeparam name="T2">The second value type.</typeparam>
    /// <typeparam name="TParam">The parameter type.</typeparam>
    /// <param name="value1">The first value to validate.</param>
    /// <param name="value2">The second value to validate.</param>
    /// <param name="param">The parameter to validate.</param>
    /// <param name="predicate">The predicate to validate.</param>
    /// <param name="messageFormatter">The message formatter.</param>
    /// <param name="property1">The first property name.</param>
    /// <param name="property2">The second property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    public RuleSet BothMust<T1, T2, TParam>(
        T1 value1,
        T2 value2,
        TParam param,
        Func<T1, T2, TParam, bool> predicate,
        Func<string, string, T1, T2, TParam, string> messageFormatter,
        [CallerArgumentExpression(nameof(value1))] string? property1 = null,
        [CallerArgumentExpression(nameof(value2))] string? property2 = null)
    {
        if (predicate(value1, value2, param))
            return this;

        property1 = RemovePrefix(property1);
        property2 = RemovePrefix(property2);
        var property1Name = DisplayNames.Instance.GetDisplayName(type, property1);
        var property2Name = DisplayNames.Instance.GetDisplayName(type, property2);

        return WithProblem(Problems.InvalidParameter(
            messageFormatter(property1Name, property2Name, value1, value2, param)));
    }

    #endregion

    #region Mist

    /// <summary>
    /// <para>
    ///     Validates a string to ensure that the value is a valid email address.
    /// </para>
    /// <para>
    ///     The validation is based on the <see cref="EmailAddressAttribute"/> attribute validation.
    /// </para>
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Email(string? value, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        if (BuildInPredicates.IsEmail(value))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.EmailMessageTemplate, propertyName), property));
    }

    /// <summary>
    /// <para>
    ///     Validates a string to ensure that the value is a valid URL.
    /// </para>
    /// <para>
    ///     The validation is based on the <see cref="UrlAttribute"/> attribute validation.
    /// </para>
    /// </summary>
    /// <param name="value">The string value to validate.</param>
    /// <param name="property">The property name.</param>
    /// <returns>A <see cref="RuleSet"/> reference.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Url(string? value, [CallerArgumentExpression(nameof(value))] string? property = null)
    {
        if (BuildInPredicates.IsUrl(value))
            return this;

        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.UrlMessageTemplate, propertyName), property));
    }

    #endregion

    #region Nested

    /// <summary>
    /// Validates a nested value to ensure that it is not null and applies the specified nested validations.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="value">The nested value to validate.</param>
    /// <param name="nestedValidations">A function that takes the nested value and returns a collection of problems if validation fails.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNullNested<T>(
        T? value,
        Func<T, Problems?> nestedValidations,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : class
    {
        if (value is null)
            return NullOrEmptyProblem(property);

        return Nested(value, nestedValidations, property);
    }

    /// <summary>
    /// Validates a collection of nested values to ensure that it is not null and applies the specified nested validations.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="values">The collection of nested values to validate.</param>
    /// <param name="nestedValidations">A function that takes the nested value and returns a collection of problems if validation fails.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNullNested<T>(
        IEnumerable<T>? values,
        Func<T, Problems?> nestedValidations,
        [CallerArgumentExpression(nameof(values))] string? property = null)
        where T : class
    {
        if (values is null)
            return NullOrEmptyProblem(property);

        return Nested(values, nestedValidations, property);
    }

    /// <summary>
    /// Validates a nested value to ensure that it is not null and applies the specified <see cref="ValidateFunc"/>.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="value">The nested value to validate.</param>
    /// <param name="validation">A function that takes the nested value and returns a validation result.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNullNested<T>(
        T? value,
        Func<T, ValidateFunc> validation,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : class
    {
        if (value is null)
            return NullOrEmptyProblem(property);

        return Nested(value, validation, property);
    }

    /// <summary>
    /// Validates a collection of nested values to ensure that it is not null and applies the specified <see cref="ValidateFunc"/>.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="values">The collection of nested values to validate.</param>
    /// <param name="validation">A function that takes the nested value and returns a validation result.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNullNested<T>(
        IEnumerable<T>? values,
        Func<T, ValidateFunc> validation,
        [CallerArgumentExpression(nameof(values))] string? property = null)
        where T : class
    {
        if (values is null)
            return NullOrEmptyProblem(property);

        return Nested(values, validation, property);
    }

    /// <summary>
    /// Validates a nested value to ensure that it is not null and applies the specified nested validations.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="value">The nested value to validate.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNullNested<T>(
        T? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : class, IValidable
    {
        if (value is null)
            return NullOrEmptyProblem(property);

        return Nested(value, property);
    }

    /// <summary>
    /// Validates a collection of nested values to ensure that it is not null and applies the specified nested validations.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="values">The collection of nested values to validate.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet NotNullNested<T>(
        IEnumerable<T>? values,
        [CallerArgumentExpression(nameof(values))] string? property = null)
        where T : class, IValidable
    {
        if (values is null)
            return NullOrEmptyProblem(property);

        return Nested(values, property);
    }

    /// <summary>
    /// Validates a nested value with the specified nested validations.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="value">The nested value to validate.</param>
    /// <param name="nestedValidations">A function that takes the nested value and returns a collection of problems if validation fails.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Nested<T>(
        T? value,
        Func<T, Problems?> nestedValidations,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : class
    {
        if (value is null)
            return this;

        var nestedProblems = nestedValidations(value);
        if (nestedProblems is null)
            return this;

        foreach (var problem in nestedProblems)
            problem.ChainProperty(RemovePrefix(property));

        if (problems is null)
            return new RuleSet(type, nestedProblems, propertyPrefix);

        problems.AddRange(nestedProblems);
        return new RuleSet(type, problems, propertyPrefix);
    }

    /// <summary>
    /// Validates a collection of nested values with the specified nested validations.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="values">The collection of nested values to validate.</param>
    /// <param name="nestedValidations">A function that takes the nested value and returns a collection of problems if validation fails.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Nested<T>(
        IEnumerable<T>? values,
        Func<T, Problems?> nestedValidations,
        [CallerArgumentExpression(nameof(values))] string? property = null)
        where T : class
    {
        if (values is null)
            return this;

        Problems? allProblems = problems;

        foreach (var value in values)
        {
            var nestedProblems = nestedValidations(value);
            if (nestedProblems is null)
                continue;

            foreach (var problem in nestedProblems)
                problem.ChainProperty(RemovePrefix(property));

            if (allProblems is null)
                allProblems = nestedProblems;
            else
                allProblems.AddRange(nestedProblems);
        }

        if (allProblems is null)
            return this;

        return new RuleSet(type, allProblems, propertyPrefix);
    }

    /// <summary>
    /// Validates a nested value with the <see cref="ValidateFunc"/> of the specified type.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="value">The nested value to validate.</param>
    /// <param name="validation">A function that takes the nested value and returns a validation result.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Nested<T>(
        T? value,
        Func<T, ValidateFunc> validation,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : class
    {
        if (value is not null && validation(value)(out var nestedProblems))
        {
            foreach (var problem in nestedProblems)
                problem.ChainProperty(RemovePrefix(property));

            if (problems is null)
                return new RuleSet(type, nestedProblems, propertyPrefix);

            problems.AddRange(nestedProblems);
            return new RuleSet(type, problems, propertyPrefix);
        }

        return this;
    }

    /// <summary>
    /// Validates a collection of nested values with the <see cref="ValidateFunc"/> of the specified type.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="values">The collection of nested values to validate.</param>
    /// <param name="validation">A function that takes the nested value and returns a validation result.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Nested<T>(
        IEnumerable<T>? values,
        Func<T, ValidateFunc> validation,
        [CallerArgumentExpression(nameof(values))] string? property = null)
        where T : class
    {
        if (values is null)
            return this;

        Problems? allProblems = problems;

        foreach (var value in values)
            if (value is not null && validation(value)(out var nestedProblems))
            {
                foreach (var problem in nestedProblems)
                    problem.ChainProperty(RemovePrefix(property));

                if (allProblems is null)
                    allProblems = nestedProblems;
                else
                    allProblems.AddRange(nestedProblems);
            }

        if (allProblems is null)
            return this;

        return new RuleSet(type, allProblems, propertyPrefix);
    }

    /// <summary>
    /// Validates a nested value to ensure that it is not null and implements the <see cref="IValidable"/> interface.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="value">The nested value to validate.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Nested<T>(
        T? value,
        [CallerArgumentExpression(nameof(value))] string? property = null)
        where T : class, IValidable
    {
        if (value is not null && value.HasProblems(out var nestedProblems))
        {
            foreach (var problem in nestedProblems)
                problem.ChainProperty(property);

            if (problems is null)
                return new RuleSet(type, nestedProblems, propertyPrefix);

            problems.AddRange(nestedProblems);
            return new RuleSet(type, problems, propertyPrefix);
        }

        return this;
    }

    /// <summary>
    /// Validates a collection of nested values to ensure that they are not null and implement the <see cref="IValidable"/> interface.
    /// </summary>
    /// <typeparam name="T">The type of the nested value.</typeparam>
    /// <param name="values">The collection of nested values to validate.</param>
    /// <param name="property">The name of the property being validated.</param>
    /// <returns>A RuleSet containing validation problems, if any.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RuleSet Nested<T>(
        IEnumerable<T>? values,
        [CallerArgumentExpression(nameof(values))] string? property = null)
        where T : class, IValidable
    {
        if (values is null)
            return this;

        var allProblems = problems;

        foreach (var value in values)
            if (value is not null && value.HasProblems(out var nestedProblems))
            {
                foreach (var problem in nestedProblems)
                    problem.ChainProperty(property);

                if (allProblems is null)
                    allProblems = nestedProblems;
                else
                    allProblems.AddRange(nestedProblems);
            }

        if (allProblems is null)
            return this;

        return new RuleSet(type, allProblems, propertyPrefix);
    }


    #endregion

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet NullOrEmptyProblem(string? property)
    {
        property = RemovePrefix(property);
        var propertyName = DisplayNames.Instance.GetDisplayName(type, property);

        return WithProblem(Problems.InvalidParameter(
            string.Format(R.NotNullOrEmptyMessageTemplate, propertyName), property));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private string? RemovePrefix(string? property)
    {
        if (propertyPrefix is not null && property is not null && property.StartsWith($"{propertyPrefix}."))
            return property.Substring(propertyPrefix.Length + 1);

        return property;
    }
}
